/// Miscellaneous stuff that is used by both Client and Server
namespace Shared


// NOTE: API endpoints should be defined by taking into account:
// - The route-building function below, which uses compiled names of types and methods
// - HTTP requests generated by Fable: https://zaid-ajaj.github.io/Fable.Remoting/src/raw-http
// - REST API recommendations (e.g. prefer kebab-case names and simple JSON data)

module Route =
    let builder typeName methodName = $"/api/{typeName}/{methodName}"


open System

type Todo = { Id: Guid; Description: string }

type ITodosApi =
    { getTodos: unit -> Async<Todo list>
      addTodo: Todo -> Async<Todo> }

module Todo =
    let isValid (description: string) =
        String.IsNullOrWhiteSpace description |> not

    let create (description: string) =
        { Id = Guid.NewGuid()
          Description = description }


open Formal.Languages

// maps don't serialize to JSON that well, so we use sets of tuples instead
type private DeterministicTransitions = Set<(State * Symbol) * State>
type private NondeterministicTransitions = Set<(State * option<Symbol>) * Set<State>>
type private DeterminizedTransitions = Set<(Set<State> * Symbol) * Set<State>>

type NondeterministicAutomaton =
    { transitions: NondeterministicTransitions
      initial: Set<State>
      accepting: Set<State> }

type EpsilonClosureArgs =
    { initial: State
      transitions: NondeterministicTransitions }

type automata =
    { determinization: NondeterministicTransitions -> Async<DeterminizedTransitions>
      indeterminization: DeterministicTransitions -> Async<NondeterministicTransitions>
      union: NondeterministicAutomaton -> NondeterministicAutomaton -> Async<NondeterministicAutomaton>
      hash: Object -> Async<string>
      ``epsilon-closure``: EpsilonClosureArgs -> Async<Set<State>> }

/// Shared automata examples.
module Automata =
    open Formal.Automata

    // functional DSL style
    let inline private map s = Map.ofSeq s

    /// DFA over {0,1} that accepts even binary numbers with at least one digit.
    let even =
        { Dead = "dead"
          Current = "empty"
          Accepting = set [ "even" ]
          Transitions =
              map [
                  ("empty", '0'), "even"
                  ("empty", '1'), "odd"
                  ("even", '0'), "even"
                  ("even", '1'), "odd"
                  ("odd", '0'), "even"
                  ("odd", '1'), "odd"
              ] }

    // NFA over {a,b} that accepts strings containing "abba" as a substring.
    let abba =
        { Current = set [ "$" ]
          Accepting = set [ "ABBA" ]
          Transitions =
              map [
                  ("$", Some 'a'), set [ "$"; "A" ]
                  ("$", Some 'b'), set [ "$" ]
                  ("A", Some 'b'), set [ "AB" ]
                  ("AB", Some 'b'), set [ "ABB" ]
                  ("ABB", Some 'a'), set [ "ABBA" ]
                  ("ABBA", Some 'a'), set [ "ABBA" ]
                  ("ABBA", Some 'b'), set [ "ABBA" ]
              ] }

    /// NFA with cyclic and reflexive epsilon transitions, rejects all input.
    let cyclic =
        { Current = set [ "A" ]
          Accepting = set []
          Transitions =
              map [
                  ("A", Automaton.epsilon), set [ "A"; "B"; "C" ]
                  ("B", Automaton.epsilon), set []
                  ("C", Automaton.epsilon), set [ "B"; "A" ]
              ] }
