/// Miscellaneous stuff that is used by both Client and Server
namespace Shared


// NOTE: API endpoints should be defined by taking into account:
// - The route-building function below, which uses compiled names of types and methods
// - HTTP requests generated by Fable: https://zaid-ajaj.github.io/Fable.Remoting/src/raw-http
// - REST API recommendations (e.g. prefer kebab-case names and simple JSON data)

module Route =
    let builder typeName methodName = $"/api/{typeName}/{methodName}"


open System

type Todo = { Id: Guid; Description: string }

type ITodosApi =
    { getTodos: unit -> Async<Todo list>
      addTodo: Todo -> Async<Todo> }

module Todo =
    let isValid (description: string) =
        String.IsNullOrWhiteSpace description |> not

    let create (description: string) =
        { Id = Guid.NewGuid()
          Description = description }


// type aliases to make the following code more readable
type private State = string
type private Input = char

// maps don't serialize to JSON that well, so we use sets of tuples instead
type private DeterministicTransitions = Set<(State * Input) * State>
type private NondeterministicTransitions = Set<(State * option<Input>) * Set<State>>
type private DeterminizedTransitions = Set<(Set<State> * Input) * Set<State>>

type automata =
    { determinize: NondeterministicTransitions -> Async<DeterminizedTransitions>
      ``epsilon-closure``: {| state: State
                              transitions: NondeterministicTransitions |} -> Async<Set<State>>
      indeterminize: DeterministicTransitions -> Async<NondeterministicTransitions> }

/// Shared automata examples.
module Automata =
    open Formal.Languages
    open Formal.Automata

    let inline map s = Map.ofSeq s

    /// DFA over {0,1} that accepts even binary numbers with at least one digit.
    let even : Dfa<State, Input> =
        { Dead = "dead"
          Current = "empty"
          Accepting = set [ "even" ]
          Transitions =
              map [
                  ("empty", '0'), "even"
                  ("empty", '1'), "odd"
                  ("even", '0'), "even"
                  ("even", '1'), "odd"
                  ("odd", '0'), "even"
                  ("odd", '1'), "odd"
              ] }

    // NFA over {a,b} that accepts strings containing "abba" as a substring.
    let abba : Nfa<State, Input> =
        { Current = set [ "$" ]
          Accepting = set [ "ABBA" ]
          Transitions =
              map [
                  ("$", Some 'a'), set [ "$"; "A" ]
                  ("$", Some 'b'), set [ "$" ]
                  ("A", Some 'b'), set [ "AB" ]
                  ("AB", Some 'b'), set [ "ABB" ]
                  ("ABB", Some 'a'), set [ "ABBA" ]
                  ("ABBA", Some 'a'), set [ "ABBA" ]
                  ("ABBA", Some 'b'), set [ "ABBA" ]
              ] }

    /// NFA with cyclic and reflexive epsilon transitions, rejects all input.
    let cyclic : Nfa<State, Input> =
        { Current = set [ "A" ]
          Accepting = set []
          Transitions =
              map [
                  ("A", Automaton.epsilon), set [ "A"; "B"; "C" ]
                  ("B", Automaton.epsilon), set []
                  ("C", Automaton.epsilon), set [ "B"; "A" ]
              ] }
